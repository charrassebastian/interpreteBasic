; This is the Calva evaluation results output window.
; TIPS: The keyboard shortcut `ctrl+alt+o o` shows and focuses this window
;   when connected to a REPL session.
; Please see https://calva.io/output/ for more info.
; Happy coding! ♥️

; Jacking in...
; Connecting using "Leiningen" project type.
; You can make Calva auto-select this.
;   - See https://calva.io/connect-sequences/
; 
; Starting Jack-in Terminal: pushd /home/sebastian/Projects/interpreteBasic/interprete ; lein update-in :dependencies conj '[nrepl,"1.0.0"]' -- update-in :plugins conj '[cider/cider-nrepl,"0.28.5"]' -- update-in '[:repl-options,:nrepl-middleware]' conj '["cider.nrepl/cider-middleware"]' -- repl :headless ; popd
; Using host:port 127.0.0.1:34023 ...
; Hooking up nREPL sessions ...
; Connected session: clj
; TIPS:
;   - You can edit the contents here. Use it as a REPL if you like.
;   - `alt+enter` evaluates the current top level form.
;   - `ctrl+enter` evaluates the current form.
;   - `alt+up` and `alt+down` traverse up and down the REPL command history
;      when the cursor is after the last contents at the prompt
;   - Clojure lines in stack traces are peekable and clickable.
; Evaluating code from settings: 'calva.autoEvaluateCode.onConnect.clj'
nil
clj꞉interprete.interprete꞉>  ; Use `alt+enter` to evaluate
clj꞉interprete.interprete꞉> 
; Jack-in done.
clj꞉interprete.interprete꞉> 
; Evaluating file: interprete.clj
true
clj꞉interprete.interprete꞉> 
; Evaluating file: core_test.clj
sentencia: (LET X = ( LEN "HOLA" ))
tokens para calcular-rpn: ("HOLA" LEN)
argumento para eliminar-cero-decimal: "HOLA"
token por aplicar: LEN
operando: "HOLA"
operador: LEN
operando nulo?: false
argumento para eliminar-cero-decimal: 4
ocurrio el primer error?: false
valor-expresion: 4
tokens para calcular-rpn: ("HOLA" LEN)
argumento para eliminar-cero-decimal: "HOLA"
token por aplicar: LEN
operando: "HOLA"
operador: LEN
operando nulo?: false
argumento para eliminar-cero-decimal: 4
ocurrio el primer error?: false
tokens para calcular-rpn: (8 1 < 8 26 > OR)
argumento para eliminar-cero-decimal: 8
argumento para eliminar-cero-decimal: 1
operador: <
argumento para eliminar-cero-decimal: 0
argumento para eliminar-cero-decimal: 8
argumento para eliminar-cero-decimal: 26
operador: >
argumento para eliminar-cero-decimal: 0
operador: OR
argumento para eliminar-cero-decimal: 0
ocurrio el primer error?: false
0
clj꞉interprete.core-test꞉> 
; Running all project tests…
tokens para calcular-rpn: (5)
argumento para eliminar-cero-decimal: 5
ocurrio el primer error?: false
tokens para calcular-rpn: (5)
argumento para eliminar-cero-decimal: 5
ocurrio el primer error?: false
tokens para calcular-rpn: (2 1 +)
argumento para eliminar-cero-decimal: 2
argumento para eliminar-cero-decimal: 1
operador: +
argumento para eliminar-cero-decimal: 3
ocurrio el primer error?: false
tokens para calcular-rpn: ("HOLA" " MUNDO" +)
argumento para eliminar-cero-decimal: "HOLA"
argumento para eliminar-cero-decimal: " MUNDO"
operador: +
argumento para eliminar-cero-decimal: "HOLA MUNDO"
ocurrio el primer error?: false
e: IF
e: X
e: &
e: *
e: Y
e: <
e: 12
e: THEN
e: LET
e: !
e: X
e: =
e: 0
e: PRINT
e: 5
e: PRINT
e: "HOLA"
e: LET
e: X
e: =
e: LEN
e: (
e: "HOLA"
e: )
?RETURN WITHOUT GOSUB  ERROR IN 20operador: -u
operando nulo?: false
operador: LEN
operando nulo?: false
operador: STR$
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: STR$
operando nulo?: false
operador: CHR$
operando nulo?: false
?ILLEGAL QUANTITY  ERROR IN 1operador: CHR$
operando nulo?: false
?ILLEGAL QUANTITY  ERROR IN 1operador: CHR$
operando nulo?: false
operador: INT
operando nulo?: false
operador: INT
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: SIN
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: SIN
operando nulo?: false
operador: LOG
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: LOG
operando nulo?: false
operador: EXP
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: EXP
operando nulo?: false
operador: ASC
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: ASC
operando nulo?: false
operador: ATN
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: ATN
operando nulo?: false
operador: +
operador: +
operador: -
operador: *
operador: /
?DIVISION BY ZERO  ERROR IN 1operador: /
operador: AND
operador: AND
operador: AND
operador: AND
operador: OR
operador: OR
operador: OR
operador: OR
operador: <>
operador: <>
operador: <>
operador: <>
operador: <
?TYPE MISMATCH  ERROR IN 1operador: <
operador: <
operador: <
operador: <=
?TYPE MISMATCH  ERROR IN 1operador: <=
operador: <=
operador: <=
operador: >
?TYPE MISMATCH  ERROR IN 1operador: >
operador: >
operador: >
operador: >=
?TYPE MISMATCH  ERROR IN 1operador: >=
operador: >=
operador: >=
operador: =
operador: =
operador: =
operador: =
operador: MID$
?ILLEGAL QUANTITY  ERROR IN 1operador: MID$
operador: MID3$
?ILLEGAL QUANTITY  ERROR IN 1operador: MID3$
?ILLEGAL QUANTITY  ERROR IN 1operador: MID3$
sentencia: (DATA 10)
sentencia: (END)
sentencia: (READ X)
sentencia: (READ X)
sentencia: (RESTORE)
sentencia: (CLEAR)
sentencia: (LIST)
sentencia: (LET X 4)
tokens para calcular-rpn: (nil)
argumento para eliminar-cero-decimal: nil
ocurrio el primer error?: false
valor-expresion: nil
sentencia: (LET X = PRINT)
tokens para calcular-rpn: (PRINT)
argumento para eliminar-cero-decimal: PRINT
ocurrio el primer error?: false
valor-expresion: PRINT
sentencia: (LET X = 5)
tokens para calcular-rpn: (5)
argumento para eliminar-cero-decimal: 5
ocurrio el primer error?: false
valor-expresion: 5
sentencia: (LET X = 5)
tokens para calcular-rpn: (5)
argumento para eliminar-cero-decimal: 5
ocurrio el primer error?: false
valor-expresion: 5
; 267 tests finished, all passing 👍, ns: 1, vars: 26
clj꞉interprete.core-test꞉> 
sentencia: (LET X = ( LEN "HOLA" ))
tokens para calcular-rpn: ("HOLA" LEN)
argumento para eliminar-cero-decimal: "HOLA"
token por aplicar: LEN
operando: "HOLA"
operador: LEN
operando nulo?: false
argumento para eliminar-cero-decimal: 4
ocurrio el primer error?: false
valor-expresion: 4
[:sin-errores [() [:ejecucion-inmediata 0] [] [] [] 0 {X 4}]]
clj꞉interprete.core-test꞉> 
sentencia: (LET X = ( LEN "HOLA" ))
tokens para calcular-rpn: ("HOLA" LEN)
argumento para eliminar-cero-decimal: "HOLA"
token por aplicar: LEN
operando: "HOLA"
operador: LEN
operando nulo?: false
argumento para eliminar-cero-decimal: 4
ocurrio el primer error?: false
valor-expresion: 4
[:sin-errores [() [:ejecucion-inmediata 0] [] [] [] 0 {X 4}]]
clj꞉interprete.core-test꞉> 
; Evaluating file: core_test.clj
sentencia: (LET X = ( LEN "HOLA" ))
tokens para calcular-rpn: ("HOLA" LEN)
argumento para eliminar-cero-decimal: "HOLA"
token por aplicar: LEN
operando: "HOLA"
operador: LEN
operando nulo?: false
argumento para eliminar-cero-decimal: 4
ocurrio el primer error?: false
valor-expresion: 4
sentencia: (LET X = MID$ ( MID$ ) "HOLA" , 2 ) , 2 ))
; Syntax error (StackOverflowError) compiling at (core_test.clj:479:1).
; null
; Evaluation of file core_test.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉interprete.core-test꞉> 
sentencia: (LET X = MID$ ( MID$ ) "HOLA" , 2 ) , 2 ))
; Execution error (StackOverflowError) at interprete.interprete/desambiguar-mid (interprete.clj:381).
; null
clj꞉interprete.core-test꞉> 
("HOLA" LEN)
clj꞉interprete.core-test꞉> 
tokens para calcular-rpn: ("HOLA" LEN)
argumento para eliminar-cero-decimal: "HOLA"
token por aplicar: LEN
operando: "HOLA"
operador: LEN
operando nulo?: false
argumento para eliminar-cero-decimal: 4
ocurrio el primer error?: false
4
clj꞉interprete.core-test꞉> 
(LEN ( "HOLA" ))
clj꞉interprete.core-test꞉> 
true
clj꞉interprete.core-test꞉> 
; Evaluating file: core_test.clj
sentencia: (LET X = ( LEN "HOLA" ))
tokens para calcular-rpn: ("HOLA" LEN)
argumento para eliminar-cero-decimal: "HOLA"
token por aplicar: LEN
operando: "HOLA"
operador: LEN
operando nulo?: false
argumento para eliminar-cero-decimal: 4
ocurrio el primer error?: false
valor-expresion: 4
sentencia: (LET X = MID$ ( MID$ ) "HOLA" , 2 ) , 2 ))
; Syntax error (StackOverflowError) compiling at (core_test.clj:479:1).
; null
; Evaluation of file core_test.clj failed: class clojure.lang.Compiler$CompilerException
clj꞉interprete.core-test꞉> 
; Evaluating file: core_test.clj
#'interprete.core-test/evaluar-tests
clj꞉interprete.core-test꞉> 
; Evaluating file: interprete.clj
true
clj꞉interprete.interprete꞉> 
; Running all project tests…
tokens para calcular-rpn: (5)
argumento para eliminar-cero-decimal: 5
ocurrio el primer error?: false
tokens para calcular-rpn: (5)
argumento para eliminar-cero-decimal: 5
ocurrio el primer error?: false
tokens para calcular-rpn: (2 1 +)
argumento para eliminar-cero-decimal: 2
argumento para eliminar-cero-decimal: 1
operador: +
argumento para eliminar-cero-decimal: 3
ocurrio el primer error?: false
tokens para calcular-rpn: ("HOLA" " MUNDO" +)
argumento para eliminar-cero-decimal: "HOLA"
argumento para eliminar-cero-decimal: " MUNDO"
operador: +
argumento para eliminar-cero-decimal: "HOLA MUNDO"
ocurrio el primer error?: false
e: IF
e: X
e: &
e: *
e: Y
e: <
e: 12
e: THEN
e: LET
e: !
e: X
e: =
e: 0
e: PRINT
e: 5
e: PRINT
e: "HOLA"
e: LET
e: X
e: =
e: LEN
e: (
e: "HOLA"
e: )
?RETURN WITHOUT GOSUB  ERROR IN 20operador: -u
operando nulo?: false
operador: LEN
operando nulo?: false
operador: STR$
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: STR$
operando nulo?: false
operador: CHR$
operando nulo?: false
?ILLEGAL QUANTITY  ERROR IN 1operador: CHR$
operando nulo?: false
?ILLEGAL QUANTITY  ERROR IN 1operador: CHR$
operando nulo?: false
operador: INT
operando nulo?: false
operador: INT
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: SIN
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: SIN
operando nulo?: false
operador: LOG
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: LOG
operando nulo?: false
operador: EXP
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: EXP
operando nulo?: false
operador: ASC
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: ASC
operando nulo?: false
operador: ATN
operando nulo?: false
?TYPE MISMATCH  ERROR IN 1operador: ATN
operando nulo?: false
operador: +
operador: +
operador: -
operador: *
operador: /
?DIVISION BY ZERO  ERROR IN 1operador: /
operador: AND
operador: AND
operador: AND
operador: AND
operador: OR
operador: OR
operador: OR
operador: OR
operador: <>
operador: <>
operador: <>
operador: <>
operador: <
?TYPE MISMATCH  ERROR IN 1operador: <
operador: <
operador: <
operador: <=
?TYPE MISMATCH  ERROR IN 1operador: <=
operador: <=
operador: <=
operador: >
?TYPE MISMATCH  ERROR IN 1operador: >
operador: >
operador: >
operador: >=
?TYPE MISMATCH  ERROR IN 1operador: >=
operador: >=
operador: >=
operador: =
operador: =
operador: =
operador: =
operador: MID$
?ILLEGAL QUANTITY  ERROR IN 1operador: MID$
operador: MID3$
?ILLEGAL QUANTITY  ERROR IN 1operador: MID3$
?ILLEGAL QUANTITY  ERROR IN 1operador: MID3$
sentencia: (DATA 10)
sentencia: (END)
sentencia: (READ X)
sentencia: (READ X)
sentencia: (RESTORE)
sentencia: (CLEAR)
sentencia: (LIST)
sentencia: (LET X 4)
tokens para calcular-rpn: (nil)
argumento para eliminar-cero-decimal: nil
ocurrio el primer error?: false
valor-expresion: nil
sentencia: (LET X = PRINT)
tokens para calcular-rpn: (PRINT)
argumento para eliminar-cero-decimal: PRINT
ocurrio el primer error?: false
valor-expresion: PRINT
sentencia: (LET X = 5)
tokens para calcular-rpn: (5)
argumento para eliminar-cero-decimal: 5
ocurrio el primer error?: false
valor-expresion: 5
sentencia: (LET X = 5)
tokens para calcular-rpn: (5)
argumento para eliminar-cero-decimal: 5
ocurrio el primer error?: false
valor-expresion: 5
; 267 tests finished, all passing 👍, ns: 1, vars: 26
clj꞉interprete.interprete꞉> 
